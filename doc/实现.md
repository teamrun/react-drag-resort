## 实现方案

mousedown时获取元素, setState设定那个元素的index, 这样就可以render时判定哪个被开始drag 设置特殊的类什么的

mousedown时同时做好计算位置的准备: `$(List).offset().top`(用原生js实现)获取List对于页面顶端的位置, 获取鼠标的e.pageY, 获取被drag的Item对于List的offsetTop. 或者这三个参数后, 就可以计算鼠标在Item上的位置: 

    mousePageY - $(List).offset().top = 鼠标对于List的位置mousePos
    mousePos - Item对于List的位置 ListPos = 鼠标对于Item的位置

将这几个数据存在this.draggin中, 方便下一步使用

mousemove时, 获取e.pageY ,然后算出Item应该在的位置, setState, 造成重新渲染.

mouseup时, 取消dragging move状态.

下一步, 就是要检测移动的过程中, 移动List中的Item, 给DraggingEl让位置

和 

mouseUp时设置数据, `setState({data: ..})`, 实现最终的重排